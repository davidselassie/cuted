#!/usr/bin/env ruby

# David Selassie
# April 28, 2011

# USAGE: cuted start | stop | run [-- ...]
# A simple process queue daemon. Add processes using the cute command.

# Requires a daemonizer!
require 'daemons'
# Also requires this simple config parser.
require 'parseconfig'
require 'logger'
require 'drb'

require_relative 'cutequeue'

Daemons.run_proc('cuted', :dir => '~', :log_output => true) do
  logger = Logger.new(STDOUT)

  # Set up defaults that might be overwritten.
  config = {'max_concurrent' => 4, 'log' => 'cute.log', 'server_pipe' => '~/.cuted.sock'}
  # See if there's any user settings in ~/.cuterc and write them on top.
  if File.exists?(File.expand_path('~/.cuterc'))
    config.merge!(ParseConfig.new(File.expand_path('~/.cuterc')).params)
  end

  # Use the environment variable PROWLKEY if it's there.
  config['prowl_key'] = ENV['PROWLKEY'] if ENV['PROWLKEY']

  logger.info "Will run #{config['max_concurrent']} processes concurrently"
  logger.info 'Will log command outputs' if config['log']
  logger.info "Will notify Prowl key #{config['prowl_key']} of completions" if config['prowl_key']

  begin
    queue = CuteQueue.new(:logger => logger, :defaults => {:prowl_key => config['prowl_key']})
    DRb.start_service('druby://localhost:1987', queue)

    logger.info "Running on #{DRb.uri}"
    ENV['cuted_server'] = DRb.uri

    # Wait. Let clients call methods on the queue.
    DRb.thread.join
  rescue Interrupt
    logger.info 'Exiting'
  end
end
